
<h1>Sorting Algorithm </h1>
<nav>

</nav>
<p>
在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据(list)依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。<br>
基本上，排序算法的输出必须遵守下列两个原则：
输出结果为递增序列（递增是针对所需的排序顺序而言）,
输出结果是原输入的一种排列、或是重组
</p>

<section>
<h2>几种典型的排序算法</h2>

处理的数据为list,长度为n.<br>

<h3>Selection sort 基于的思想或方法:selection.</h3>
此算法将输入的list分为两部分，一部分已经排好序，由list从左向右建立的sublist，一部分剩下的未排序的list部分。开始，排好序的sublist是空，剩下的未排序的是整个list。算法每次push未排好序的sublist的第一个值到排好序的sublist里，循环比较未排好序的sublist里剩下的值，交换选择最小的值，从而保证向排好序的sublist里push了未排序的sublist里最小的值。进行n-2次循环就能使排好序的sublist里是从小到大的list里的值。
<h3>Insertion sort 基于的思想或方法:insertion.</h3>
插入排序将list考虑为一个input流,每次迭代处理list的一个元素，将这个元素push到一个 sorted list。每次迭代，插入排序移出list的一个元素，找到它在sorted list中的位置，插入它。重复直到list里的元素被处理完。
<h3>Merge sort 基于的思想或方法：merge</h3>
合并排序有两个步骤
<ol>
<li>将unsorted list分成n个sublist，每个包含一个元素（只包含一个元素的list被看作sorted</li>
<li>重复地比较，合并sublists来产生新的sorted sublists 直到这儿只剩下一个sublist。这个就是sorted list。</li>
</ol>
<h3>Quicksort 基于的思想或方法：partitioning</h3>
快速排序步骤如下：
<ol>
<li>从list里选择一个基准点pivot，一般是中心点</li>
<li>对list排序，保证比pivot小的在pivot前面，比pivot大的元素都在它后面，在这次分割后pivot会有一个最终的位置</li>
<li>对以pivot为界的两个sublists递归使用上面的方法，直到sublist只有一个元素，这样就确保生成了一个sorted list。</li>
</ol>
<h3>Bubble sort 基于的思想和方法:exchanging</h3>
冒泡排序简单地重复迭代list的每一个元素，比较相邻的元素的值，如果他们是in wrong order，就交换他们的位置。被称作冒泡是因为每第k次重复（pass）都会将kth 大的冒泡到list top。

</section>


<h2>以上算法的js实现</h2>
<h3>通用的function</h3>
<pre>
<code>
//以item的index来交换值
function swap(items, firstIndex, secondIndex){
    var temp = items[firstIndex];
    items[firstIndex] = items[secondIndex];
    items[secondIndex] = temp;
}
</code>
</pre>
<h3>Bubble sort </h3>
<pre>
<code>
function bubbleSort(items){

  var length=items.length;
  for(var i=0;i < length-1;i++){
    for(var j=0;j < length-i;j++){
      if(items[j] > items[j+1]){
        swap(items,j,j+1)
      }
    }  
  }
  return items;
}


</code>
</pre>

<p>时间复杂度:</p>

<h3>Selection sort </h3>
<div class="compareCode">

<pre>
<code>
function selectionSort(items){

  var length=items.length;
  
  for(var i=0;i < length;i++){
    for(var j=i+1;j < length;j++){
      if(items[i] > items[j])
        swap(items,i,j)
    }
  }
  return items;
}


</code>
</pre>
<pre>
<code>

function selectionSort(items){

  var length=items.length,min;
  
  for(var i=0;i < length;i++){
    min=i;
    for(var j=i+1;j < length;j++){
      if(items[min] > items[j])
        min=j
    }
    if(i!=min) swap(items,i,min)
  }
  return items;
}
//more efficient

</code>
</pre>
</div>
<p>时间复杂度:</p>
<h4>关联的</h4>
<h3>Insertion sort </h3>
<pre>
<code>
function insertionSort(items) {

    var len     = items.length,     // number of items in the array
        value,                      // the value currently being compared
        i,                          // index into unsorted section
        j;                          // index into sorted section
    
    for (i=0; i < len; i++) {
    
        // store the current value because it may shift later
        value = items[i];
        
        /*
         * 例如2,5,1 i为3,j--则依次迭代5，2，结果是都向右移1单位，变成1,2,5
         */
        for (j=i-1; j > -1 && items[j] > value; j--) {
            items[j+1] = items[j];
        }
        //将i位置的值放到它的位置
        items[j+1] = value;
    }
    
    return items;
}

</code>
</pre>

<p>时间复杂度:</p>
<h3>Merge sort </h3>
<pre>
<code>
function mergeSort(items){

 todo
}


</code>
</pre>

<p>时间复杂度:</p>
<h3>Quick sort </h3>
<pre>
<code>
function quickSort(items){

  todo
}


</code>
</pre>

<p>时间复杂度:</p>
<h2>comparison and conlusion</h2>
<h3></h3>

<pre>
<code>

</code>
</pre>

<span> reference: <a href="https://en.wikipedia.org/wiki/Sorting_algorithm">wiki文档:Sorting algorithm</a>
<a href="http://www.nczonline.net/blog/2012/11/27/computer-science-in-javascript-quicksort/">Nicholas C. Zakas's blog</a>
</span>