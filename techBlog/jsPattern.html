1.观察者模式-Observer
用一个数组来保存多个需要触发的操作
例子如：事件管理(eventEmitter)
promise的原理，观察状态pendding,resolved,rejected,触发操作
╭─────────────╮  Fire Event  ╭──────────────╮
 │             │─────────────>│              │
 │   Subject   │              │   Observer   │
 │             │<─────────────│              │
 ╰─────────────╯  Subscribe   ╰──────────────╯

 发布订阅模式

Publisher-----publish event--------》╭─────────────╮    ╭──────────────╮Fire Event
 │             │─────────────>│              │
 │   Event Channel  │              │   Observer   │
 │             │<─────────────│              │
 ╰─────────────╯  Subscribe   ╰──────────────╯

2.外观模式-Facade
提供相应的接口，却不用管内部的实现，内部实现的代码可以很容易的修改和更新，比如今天你是用jQuery来实现的，明天又想换YUI了，这就非常方便了。

3.中介者模式-Mediator
讲modiator之前，我们先来举个例子，机场飞行控制系统，也就是传说中的塔台，具有绝对的权利，他可以控制任何一架飞机的起飞和降落时间以及地方，而飞机和飞机之前不允许通信，也就是说塔台是机场的核心，mediator就相当于这个塔台。

mediator就是用在程序里有多个模块，而你又不想让各个模块有依赖的话，那通过mediator模式可以达到集中控制的目的。实际场景中也是，mediator封装了很多不想干的模块，让他们通过mediator联系在一起，同时也松耦合他们，使得他们之间必须通过mediator才能通信。

例如：管理各模块的生命周期，可以动态添加或删除模块



