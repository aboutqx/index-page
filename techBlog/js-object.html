
<h1>js 原型，原型链和获取属性</h1>
<nav>

</nav>
<p>
JavaScript 中的每个对象都有一个内部私有的链接指向另一个对象，这个对象就是原对象的原型，注意不是对象的prototype属性，而是对象的__proto__的值。这个原型对象也有自己指向的原型，直到对象的原型为 null 为止（也就是没有原型）。这种一级一级的链结构就称为原型链。
</p>


<h2>获取对象属性</h2>
<p>
JavaScript 对象有两种不同的属性，一种是对象自身的属性，另外一种是继承于原型链上的属性。<br>
获取对象的属性的时候，先检查该属性是否是对象本身的属性，是的话则返回，不是的话，就检查属性是否在对象指向的
原型上，是的话则返回，不是的话则检查对象的指向的原型所指向的原型是否具有，是的话则返回，不是的话继续沿着原型链追溯，直至null原型，则返回undefined。
</p>
<pre>
	<code>
var X=function(){
 this.name='x' 
}
X.prototype.name='p'
var x=new X; //x.__proto__=X.prototype
x.name//返回 'x'
</code>
</pre>
<h3>列举所有属性</h3>
<ul>
	<li>for...in 列举对象和其原型链上所有可列举属性</li>
	<li>Object.keys(o) 返回o本身具有的可列举的属性数组</li>
	<li>Object.getOwnPropertyNames(o) 返回o的可列举和不可列举的属性</li>
</ul>
<pre>
<code>
function listAllProperties(o){     
	var objectToInspect;     
	var result = [];
	
	for(objectToInspect = o; objectToInspect !== null; objectToInspect = Object.getPrototypeOf(objectToInspect)){  
		result = result.concat(Object.getOwnPropertyNames(objectToInspect));  
	}
	
	return result; 
}//返回对象和原型链上的可列举和不可列举的属性
</code>
</pre>
<h2>new 到底做了什么</h2>
<pre>
<code>var mark = new WorkerBee;
mark.__proto__=WorkerBee.prototype;
</code>
</pre>
<p>
当 JavaScript 发现 new 操作符时，它会创建一个通用(generic)对象，并将其作为关键字 this 的值传递给 WorkerBee 的构造器函数。该构造器函数显式地设置 projects 属性的值，然后隐式地将其内部的 __proto__ 属性设置为 WorkerBee.prototype 的值（属性的名称前后均有两个下划线）。__proto__ 属性决定了用于返回属性值的原型链。一旦这些属性设置完成，JavaScript 返回新创建的对象，然后赋值语句会将变量 mark 的值指向该对象。<br>

这个过程不会显式的将 mark所继承的原型链中的属性值作为本地变量存放在 mark 对象中。而是通过原型链来获取属性。
</p>
<p>看这个例子</p>
<div class="compareCode">
<pre>
<code>var A=function(){
  this.name='a';
}

var B=function(){


  
}
B.prototype=Object.create(A.prototype)
var b=new B()

b.name//undefined</code>
</pre>
<pre>
<code>var A=function(){
  this.name='a';
}

var B=function(){

//this.name='b' 如果B本身具有属性name则返回该属性值
  
}
B.prototype=new A()
var b=new B()

b.name//'a'</code>
</pre></div>
<h2>使用不同的方法来创建对象和生成原型链</h2>
<h3>使用普通语法创建对象</h3>

<pre>
<code>
var o = {a: 1};

// o这个对象继承了Object.prototype上面的所有属性
// 所以可以这样使用 o.hasOwnProperty('a').
// hasOwnProperty 是Object.prototype的自身属性。
// Object.prototype的原型为null。
// 原型链如下:
// o ---> Object.prototype ---> null

var a = ["yo", "whadup", "?"];

// 数组都继承于Array.prototype (indexOf, forEach等方法都是从它继承而来).
// 原型链如下:
// a ---> Array.prototype ---> Object.prototype ---> null

function f(){
  return 2;
}

// 函数都继承于Function.prototype(call, bind等方法都是从它继承而来):
// f ---> Function.prototype ---> Object.prototype ---> null
</code>
</pre>
<h3>使用构造方法创建对象</h3>

在 JavaScript 中，构造方法其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。
<pre>
	<code>
function Graph() {
  this.vertexes = [];
  this.edges = [];
}

Graph.prototype = {
  addVertex: function(v){
    this.vertexes.push(v);
  }
};

var g = new Graph();
// g是生成的对象,他的自身属性有'vertexes'和'edges'.
// 在g被实例化时,g.[[Prototype]]指向了Graph.prototype.

</code>
</pre>
<h3>使用 Object.create 创建对象</h3>
ECMAScript 5 中引入了一个新方法：Object.create。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：
<pre>
	<code>
var a = {a: 1}; 
// a ---> Object.prototype ---> null

var b = Object.create(a);
// b ---> a ---> Object.prototype ---> null
console.log(b.a); // 1 (继承而来)

var c = Object.create(b);
// c ---> b ---> a ---> Object.prototype ---> null

var d = Object.create(null);
// d ---> null
console.log(d.hasOwnProperty); // undefined, 因为d没有继承Object.prototype
</code>
</pre>
<span> reference: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">MDN文档:Inheritance and the prototype chain</a></span>