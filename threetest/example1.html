<canvas width=600 height=400></canvas>
    <script src="sylvester.js" type="text/javascript"></script>
    <script src="glUtils.js" type="text/javascript"></script>
<script id="vertexshader" type="x-shader/x-vertex">
attribute vec3 a_position;
uniform mat4 uPmatrix;
uniform mat4 uMVmatrix;
void main() {
  gl_Position = uMVmatrix*vec4(a_position,1.0);
}
</script>

<script id="fragmentshader" type="x-shader/x-fragment">
void main() {
  gl_FragColor = vec4(0, 1, 0, 1);  // green
}
</script>
<script>
// Get A WebGL context
var canvas = document.querySelector("canvas");
var gl = canvas.getContext("webgl");

// setup a GLSL program
var vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader,document.querySelector('#vertexshader').innerHTML);
gl.compileShader(vertexShader);
var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader,document.querySelector('#fragmentshader').innerHTML);
gl.compileShader(fragmentShader);

var program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);


gl.linkProgram(program);
console.log(gl.getProgramParameter(program,gl.LINK_STATUS))
gl.useProgram(program);

// look up where the vertex data needs to go.
var positionLocation = gl.getAttribLocation(program, "a_position");

// Create a buffer and put a single clipspace rectangle in
// it (2 triangles)
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(
    gl.ARRAY_BUFFER,
    new Float32Array([
        -1.0, -1.0,-1,
         1.0, -1.0,-1,
        -1.0,  1.0,-1,
        -1.0,  1.0,-1,
         1.0, -1.0,-1,
         1.0,  1.0,-1]),
    gl.STATIC_DRAW);
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

var perspectiveMatrix = makePerspective(55, 600.0/400.0, 0.1, 800.0);
var mvMatrix;
var mvMatrixStack = [];
loadIdentity();
  // Now move the drawing position a bit to where we want to start
  // drawing the cube.

//mvTranslate([0.0, 0.0, 0.0]);

// Save the current matrix, then rotate before we draw.
var cubeRotation = 0.0;
var cubeXOffset = 0.0;
var cubeYOffset = 0.0;
var cubeZOffset = 0.0;
mvMatrix=makeTranslation(0,0,0)
//mvPushMatrix();
//mvRotate(cubeRotation, [1, 0, 1]);
//mvTranslate([cubeXOffset, cubeYOffset, cubeZOffset]);

program.pMatrixUniform = gl.getUniformLocation(program, 'uPMatrix');
gl.uniformMatrix4fv(program.pMatrixUniform, false, perspectiveMatrix.flatten());
program.pMatrixUniform = gl.getUniformLocation(program, 'uMVMatrix');
gl.uniformMatrix4fv(program.pMatrixUniform, false, mvMatrix);
gl.drawArrays(gl.TRIANGLES, 0, 6);

function makeTranslation(tx, ty, tz) {
  return [
     1,  0,  0,  0,
     0, 1,  0,  0,
     0,  0,  1,  0,
    0, 0, 0,  1
  ];
}
function loadIdentity() {
  mvMatrix = Matrix.I(4);
}

function multMatrix(m) {
  mvMatrix = mvMatrix.x(m);
}

function mvTranslate(v) {
  multMatrix(Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4());
}

function setMatrixUniforms() {
  var pUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
  gl.uniformMatrix4fv(pUniform, false, new Float32Array(perspectiveMatrix.flatten()));

  var mvUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
  gl.uniformMatrix4fv(mvUniform, false, new Float32Array(mvMatrix.flatten()));
}

function mvPushMatrix(m) {
  if (m) {
    mvMatrixStack.push(m.dup());
    mvMatrix = m.dup();
  } else {
    mvMatrixStack.push(mvMatrix.dup());
  }
}

function mvPopMatrix() {
  if (!mvMatrixStack.length) {
    throw("Can't pop from an empty matrix stack.");
  }

  mvMatrix = mvMatrixStack.pop();
  return mvMatrix;
}

function mvRotate(angle, v) {
  var inRadians = angle * Math.PI / 180.0;

  var m = Matrix.Rotation(inRadians, $V([v[0], v[1], v[2]])).ensure4x4();
  multMatrix(m);
}

</script>